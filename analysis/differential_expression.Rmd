---
title: "DIFFERENTIAL EXPRESSION ANALYSIS"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```
<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">
### **INTRODUCTION** 
Quality control, processing, and alignment of raw RNA sequencing data from 12 samples were done, followed by differential expression analysis. The samples are raw sequencing reads from chromosome 2 of the mouse genome generated by the NextSeq500 sequencer and were prepared in four batches, each representing a biological replicate. They were categorized into three groups (A, B, and C) for comparative analysis.  

### **METHOD**
The quality encoding of the raw FASTQ files was determined to be Phred+33 (Sanger format) through ASCII code analysis and comparing them to known quality encoding schemes.

The following tools and flags were used for  raw data preprocessing:

#### **Adapter trimming with Scythe**

The **-q sanger** flag was chosen for Phred+33 quality encoding, and **-a ${adapter}** specified the adapter sequence to be removed. The output was saved as trim1.

#### **Quality trimming with Sickle**

The **-se** flag for single-end data, **-t sanger** for Phred+33 encoding, **-q 10** to set a minimum quality threshold of 10, and **-l 50** to remove reads shorter than 50 bases, which was appropriate given most samples had 75 base pairs in the first sequence.

#### **Alignment with HISAT2**

HISAT2 aligned reads to the reference genome. The **-p 4** flag enabled parallel processing, and **--phred33** indicated Phred+33 encoding. **-U** specified single-end reads for alignment.

#### **SAM to BAM conversion and sorting with Samtools**

The Samtools tool was used to convert the SAM file to BAM format.Temporary files were removed after processing.

#### **Transcript assembly with StringTie**

StringTie assembled transcripts and estimated gene expression. The **-p 4** flag enabled parallel processing, **-t** indicated transcriptomic data, **-e** enabled gene-level quantification, and **-B** created Ballgown-compatible output. The **-G** option specified the reference GTF file, and **-o** defined the output GTF file for each sample. 

#### **Generation of expression matrix**

The prepDE.py script processed the list of GTF files to generate a gene expression matrix for differential expression analysis.

If paired-end reads were used, modifications would be necessary in the pipeline. In HISAT2, the **-U** flag for single-end reads would be replaced with **-1** and **-2** flags to indicate the paired-end read files. Similarly, Sickle would need to be run with the **-pe** flag to handle paired-end reads, and trimming would apply to both the forward and reverse read files.


### **RESULTS AND DISCUSSION**

The read statistics in **Table 1** and the distribution shown in **Figure 1** indicates high-quality sequencing data with minimal contamination rate (â‰¤0.00034) across all samples. The majority of reads were retained after preprocessing, ensuring a strong dataset for downstream analysis. The alignment rate was 100%, with most reads aligning once, and a small portion aligning multiple times due to repetitive regions. These results indicate efficient preprocessing and alignment.

</div>

<div style="text-align: center; font-size: 18px; font-family: 'Times New Roman', Times, serif;">

**Table 1 : showing read statistics for raw processed and aligned data**

| Sample   | Total Reads | Contaminated Reads | Uncontaminated Reads | Contamination Rate | Reads Kept | Reads Discarded | Aligned 0 Times | Aligned Exactly 1 Time | Aligned >1 Times | Overall Alignment Rate |
|----------|-------------|--------------------|----------------------|--------------------|------------|-----------------|-----------------|------------------------|------------------|------------------------|
| s1.c2    | 5007025        | 1549               | 5005476              | 0.000309           | 5004437    | 2588            | 82              | 4469931                | 534424           | 100%                   |
| s2.c2    | 4788617        | 1612               | 4787005              | 0.000337           | 4784964    | 3653            | 114             | 4212383                | 572467           | 100%                   |
| s3.2     | 4271937        | 1448               | 4270489              | 0.000339           | 4270088    | 1849            | 78              | 3816738                | 453272           | 100%                   |
| s4.c2    | 4826596        | 1327               | 4825269              | 0.000275           | 4824954    | 1642            | 115             | 4261623                | 563216           | 100%                   |
| s5.c2    | 4509475        | 1353               | 4508122              | 0.000300           | 4506808    | 2667            | 94              | 3940251                | 566463           | 100%                   |
| s6.c2    | 4779843        | 1040               | 4778803              | 0.000218           | 4777339    | 2504            | 95              | 4174024                | 603220           | 100%                   |
| s7.c2    | 3741884        | 1051               | 3740833              | 0.000281           | 3740622    | 1262            | 97              | 3175295                | 565230           | 100%                   |
| s8.c2    | 7709668        | 2165               | 7707503              | 0.000281           | 7707368    | 2300            | 196             | 6547955                | 1159217          | 100%                   |
| s9.c2    | 5627869        | 1407               | 5626462              | 0.000250           | 5626056    | 1813            | 104             | 5004997                | 620955           | 100%                   |
| s10.c2   | 5955048        | 1632               | 5953416              | 0.000274           | 5952253    | 2795            | 113             | 5199092                | 753048           | 100%                   |
| s11.c2   | 5020636        | 1164               | 5019472              | 0.000232           | 5019101    | 1535            | 91              | 4478001                | 541009           | 100%                   |
| s12.c2   | 4236576        | 1179               | 4235397              | 0.000278           | 4235585    | 991             | 115             | 3695614                | 539856           | 100%                   |
</div> 


```{r summary_reads , echo=FALSE,message=FALSE, warning=FALSE,fig.width=8, fig.height=5,fig.align="center"}
library(ggplot2)
library(dplyr)
library(tidyr)

# Creating a data frame from the table
read_stats <- data.frame(
  Sample = c("s1.c2", "s2.c2", "s3.c2", "s4.c2", "s5.c2", "s6.c2", "s7.c2", "s8.c2", "s9.c2", "s10.c2", "s11.c2", "s12.c2"),
  Total_Reads = c(5007025, 4788617, 4271937, 4826596, 4509475, 4779843, 3741884, 7709668, 5627869, 5955048, 5020636, 4236576),
  Contaminated_Reads = c(1549, 1612, 1448, 1327, 1353, 1040, 1051, 2165, 1407, 1632, 1164, 1179),
  Uncontaminated_Reads = c(5005476, 4787005, 4270489, 4825269, 4508122, 4778803, 3740833, 7707503, 5626462, 5953416, 5019472, 4235397),
  Reads_Kept = c(5004437, 4784964, 4270088, 4824954, 4506808, 4777339, 3740622, 7707368, 5626056, 5952253, 5019101, 4235585),
  Reads_Discarded = c(2588, 3653, 1849, 1642, 2667, 2504, 1262, 2300, 1813, 2795, 1535, 991),
  Aligned_Exactly_1 = c(4469931, 4212383, 3816738, 4261623, 3940251, 4174024, 3175295, 6547955, 5004997, 5199092, 4478001, 3695614),
  Aligned_Greater_1 = c(534424, 572467, 453272, 563216, 566463, 603220, 565230, 1159217, 620955, 753048, 541009, 539856)
)

# Converting to long format for ggplot2
read_stats_long <- read_stats %>%
  pivot_longer(cols = c(Total_Reads, Contaminated_Reads, Uncontaminated_Reads, Reads_Kept, Reads_Discarded, 
                        Aligned_Exactly_1, Aligned_Greater_1),
               names_to = "Read_Stage", values_to = "Count")

read_stats_long$Sample <- factor(read_stats_long$Sample, levels = paste0("s", 1:12, ".c2"))


# Renaming factors for better readability
read_stats_long$Read_Stage <- factor(read_stats_long$Read_Stage, 
  levels = c("Total_Reads", "Contaminated_Reads", "Uncontaminated_Reads", 
             "Reads_Kept", "Reads_Discarded", "Aligned_Exactly_1", "Aligned_Greater_1"),
  labels = c("Total Reads", "Contaminated Reads", "Uncontaminated Reads", 
             "Reads Kept", "Reads Discarded", "Aligned Exactly 1 Time", "Aligned >1 Times"))


read_stats_filtered <- read_stats_long[read_stats_long$Read_Stage %in% c("Total Reads", "Reads Kept", "Aligned Exactly 1 Time","Aligned >1 Times"), ]

# Create the grouped bar plot
ggplot(read_stats_filtered, aes(x = Sample, y = Count, fill = Read_Stage)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "", 
       x = "Sample", 
       y = "Read Count", 
       fill = "") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,face = "bold"))
```
<div style="text-align: justify ; font-family: 'Times New Roman', Times, serif;font-size: 17px">

**Figure 1: Grouped bar plot showing read distribution across processing stages with each bar indicating number of reads.**

</div>


```{r differential analysis, include=FALSE, echo=FALSE,warning=FALSE,message=FALSE}

library("DESeq2")
library("ashr")

# Load transcript and gene count matrix and convert them into matrix format 
counttable_gene = read.csv("gene_count_matrix.csv",row.names = 1)
counttable_gene = as.matrix(counttable_gene)
is.matrix(counttable_gene)

counttable_transc = read.csv("transcript_count_matrix.csv",row.names = 1)
counttable_transc = as.matrix(counttable_transc)
is.matrix(counttable_transc)

# Load Design CSV file 
coltable = read.csv("Desighn.Group.Batch.csv",header = T,row.names = 1)
# Convert group and batch into factors 
coltable$batch = as.factor(coltable$batch)
coltable$group = as.factor(coltable$group)

# Match the order of design with column names in sample data 
matching_order = match(colnames(counttable_gene), rownames(coltable))
coltable = coltable[matching_order, , drop = FALSE]
# Create dds object for gene 
dds.gene = DESeqDataSetFromMatrix(countData = counttable_gene,colData = coltable,design = ~ batch + group)

matching_order = match(colnames(counttable_transc), rownames(coltable))
coltable = coltable[matching_order, , drop = FALSE]
# Create dds object for transcripts 
dds.transc = DESeqDataSetFromMatrix(countData = counttable_transc,colData = coltable,design = ~ batch + group)

# Filter genes with minimum count of 10 reads in at least 3 samples 
dds.gene = dds.gene[rowSums(counts(dds.gene) >= 10) >= 3, ] 
dds.transc = dds.transc[rowSums(counts(dds.transc)>=10) >=3,]

# Run DEA for gene and transcript data 
dds.gene = DESeq(dds.gene)
dds.transc = DESeq(dds.transc)

# Perform rlog transformation with blind true for unbiased results since batch correction is not yet done 
rld_gene = rlog(dds.gene,blind=TRUE)
rld_transc = rlog(dds.transc,blind=TRUE)
```

```{r dispersion plot gene ,include=TRUE,echo=FALSE,,fig.width=7, fig.height=5,fig.align="center",fig.cap="**(a)**"}
# Plot for gene level
plotDispEsts(dds.gene, main="Gene Level")


```
```{r dispersion plot transcript ,include=TRUE,echo=FALSE,,fig.width=7, fig.height=5,fig.align="center",fig.cap="**(b)**" }
# Plot for transcript level
plotDispEsts(dds.transc, main="Transcript level ")

```
<div style="text-align: justify; font-family: 'Times New Roman', Times, serif;font-size: 17px">

**Figure 2: Dispersion estimate plots for gene and transcript level data. (a) Gene level dispersion estimates. (b) Transcript level dispersion estimates.**

</div>

<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

Dispersion plots **(Figure 2)** show how variance changes with mean expression. The red line represents expected dispersion, while blue dots show adjusted values after shrinkage. Gene-level data **(Figure 2a)** exhibit lower dispersion and less shrinkage than transcript-level data **(Figure 2b)** because gene expression averages signals from multiple transcript isoforms, reducing variability. In contrast, transcript-level expression is influenced by isoform (multiple transcripts of a gene) -specific factors like alternative splicing and regulation, leading to higher variability and a greater need for shrinkage to stabilize dispersion estimates.

</div>

```{r Pca function,include=TRUE,echo=FALSE}
plotPCAWithSampleNames = function(x, targets=targets, intgroup=colnames(targets)[1], ntop=500)
{
  library(RColorBrewer)
  library(genefilter)
  library(lattice)
  
  # pca
  #rv = rowVars(assay(x))
  rv = rowVars(x)
  select = order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  #pca = prcomp(t(assay(x)[select,]))
  pca = prcomp(t(x[select,]))
  
  # proportion of variance
  variance = pca$sdev^2 / sum(pca$sdev^2)
  variance = round(variance, 3) * 100
  
  # sample names
  names = colnames(x)
  #names = as.character(x$sample)
  
  # factor of groups
  #fac = factor(apply(as.data.frame(colData(x)[, intgroup, drop=FALSE]), 1, paste, collapse=" : "))
  fac = factor(apply(as.data.frame(targets[, intgroup, drop=FALSE]), 1, paste, collapse=" : "))
  
  # colors
  if( nlevels(fac) >= 10 )
    colors = rainbow(nlevels(fac))
  else if( nlevels(fac) >= 3 )
    colors = brewer.pal(nlevels(fac), "Set1")
  else
    colors = c( "dodgerblue3", "firebrick3" )
  
  # plot
  xyplot(
    PC2 ~ PC1, groups=fac, data=as.data.frame(pca$x), pch=16, cex=1.5,
    aspect = "fill",
    col = colors,
    xlab = list(paste("PC1 (", variance[1], "%)", sep=""), cex=0.8),
    ylab = list(paste("PC2 (", variance[2], "%)", sep=""), cex=0.8),
    panel = function(x, y, ...) {
      panel.xyplot(x, y, ...);
      ltext(x=x, y=y, labels=names, pos=1, offset=0.8, cex=0.7)
    },
    main = draw.key(
      key = list(
        rect = list(col = colors),
        text = list(levels(fac)),
        rep = FALSE
      )
    )
  )
}

```

```{r PCA plot gene,include=TRUE,echo=FALSE,,fig.width=6, fig.height=6,fig.align="center",message=FALSE, warning=FALSE }
# Plot PCA with sample names for gene data 
plotPCAWithSampleNames(assay(rld_gene), targets = coltable, intgroup = c("group"))

```
<div style="text-align: justify;  font-family: 'Times New Roman', Times, serif;font-size: 17px">

**Figure 3: PCA plot of rlog transformed values for gene level data showing clustering of samples with colouring based on groups**

</div>


<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

The PCA plot for gene-level data **(Figure 3)** shows a clear separation of group B from groups A and C along PC1, which explains 68.9% of the variance. Groups A and C cluster closely together along PC1, suggesting similar expression patterns. PC2 accounts for 7.3% of the variance, with group B forming a distinct cluster except for sample s8.c2. The separation of group B from A and C suggests a different expression profile, while the overlap of A and C indicates more similar expression patterns.

</div>
```{r PCA plot transcript ,echo=FALSE,fig.width=6, fig.height=6 ,eval=interactive() }
# Plot PCA with sample names for transcript data with group and batch 
plotPCAWithSampleNames(assay(rld_transc), targets = coltable, intgroup = c("group"))
plotPCAWithSampleNames(assay(rld_transc), targets = coltable, intgroup = c("batch"))

```

```{r normalized log counts, include=FALSE,echo=TRUE}
# matrix of log2(normalized-counts)
  lgc.norm =  log2(counts(dds.gene,normalized=TRUE)+1)
```

```{r mean SD plot log ,include=TRUE,echo=FALSE,,fig.width=6, fig.height=5,fig.align="center",message=FALSE, warning=FALSE,fig.cap="**(a)**"}
library(vsn)

# Mean SD plot for or log-transformed normalized counts
meanSdPlot(lgc.norm)

```

```{r mean SD plot rlog ,include=TRUE,echo=FALSE,,fig.width=6, fig.height=5,fig.align="center",message=FALSE, warning=FALSE,fig.cap="**(b)**" }
# Mean SD plot for rlog-transformed counts
meanSdPlot(assay(rld_gene))
```
<div style="text-align: justify; font-family: 'Times New Roman', Times, serif;font-size: 17px">

**Figure 4: SD versus Mean plots comparing the effect of rlog transformation on variance.
(a) Plot showing the distribution of variance for log2(normalized counts).
(b) Plot showing the distribution of variance for rlog-transformed counts, demonstrating improved homoscedasticity. **

</div>

<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

The meanSD plots**(figure 4)** shows that regularised log(rlog) transfrmation **(figure 4b)** produce more homoscedastic data compared to log transformed data **(figure 4a)**. Homoscedasticity is essential to analyse the variance across gene expression .In log2-transformed data, standard deviation is higher at lower means, indicating greater variability. In contrast, rlog transformation stabilizes variance, as shown by the flattened trend line, ensuring more consistent standard deviation. Thus, rlog transformation is preferred over log2 transformation for downstream analysis.

</div>

```{r result of DEA unshrunken fold change ,include=FALSE,echo=TRUE}
# For B vs A contrast (standard LFC = 0)
res.g.BvA = results(dds.gene,contrast=c("group","B","A"))
summary(res.g.BvA,alpha=0.05)
res_sorted_BvA = res.g.BvA[order(res.g.BvA$padj),]
head(res_sorted_BvA)
dim(res_sorted_BvA)[1]

# For C vs A contrast (standard LFC = 0)
res.g.CvA = results(dds.gene,contrast=c("group","C","A"))
summary(res.g.CvA,alpha=0.05)
res_sorted_CvA = res.g.CvA[order(res.g.CvA$padj),]
head(res_sorted_CvA)
dim(res_sorted_CvA)[1]

# For B vs A contrast with LFC < 1
res_BvA_LFC1 = results(dds.gene, contrast = c("group", "B", "A"), lfcThreshold = 1)
summary(res_BvA_LFC1,alpha=0.05)
res_sorted_BvA_LFC1 =  res_BvA_LFC1[order(res_BvA_LFC1$padj),]
head(res_sorted_BvA_LFC1)
dim(res_sorted_BvA_LFC1)[1]

# For C vs A contrast with LFC < 1
res_CvA_LFC1 = results(dds.gene, contrast = c("group", "C", "A"), lfcThreshold = 1)
summary(res_CvA_LFC1,alpha=0.05)
res_sorted_CvA_LFC1 =  res_CvA_LFC1[order(res_CvA_LFC1$padj),]
head(res_sorted_CvA_LFC1)
dim(res_sorted_CvA_LFC1)[1]

```

```{r sig genes unshrunk, include = FALSE}
# For B vs A contrast (standard LFC = 0) with adjusted p-value < 0.05
res.g.BvA_sig = res_sorted_BvA[which(res_sorted_BvA$padj < 0.05 ),]

# For C vs A contrast (standard LFC = 0) with adjusted p-value < 0.05
res.g.CvA_sig = res_sorted_CvA[which(res_sorted_CvA$padj < 0.05),]

# For B vs A contrast (LFC < 1) with adjusted p-value < 0.05
res.BvA_LFC1_sig = res_sorted_BvA_LFC1[which(res_sorted_BvA_LFC1$padj < 0.05),]

# For C vs A contrast (LFC < 1) with adjusted p-value < 0.05
res.CvA_LFC1_sig = res_sorted_CvA_LFC1[which(res_sorted_CvA_LFC1$padj < 0.05),]

# Check the number of significant genes after filtering
dim(res.g.BvA_sig)[1]  # Significant genes for B vs A
dim(res.g.CvA_sig)[1]  # Significant genes for C vs A
dim(res.BvA_LFC1_sig)[1]  # Significant genes for B vs A with LFC < 1
dim(res.CvA_LFC1_sig)[1]  # Significant genes for C vs A with LFC < 1
```

```{r result of DEA for shrunken LFC , include = FALSE}
# Shrink log-fold changes for B vs A contrast (standard LFC = 0)
res_shrink_BvA = lfcShrink(dds.gene, coef = "group_B_vs_A", type = "ashr")
summary(res_shrink_BvA)

# Shrink log-fold changes for C vs A contrast (standard LFC = 0)
res_shrink_CvA = lfcShrink(dds.gene, coef = "group_C_vs_A", type = "ashr")
summary(res_shrink_CvA)

# Shrink log-fold changes for B vs A contrast with LFC < 1
res_shrink_BvA_LFC1 = lfcShrink(dds.gene, contrast = c("group", "B", "A"), res = res_BvA_LFC1, type = "ashr")
summary(res_shrink_BvA_LFC1)

# Shrink log-fold changes for C vs A contrast with LFC < 1
res_shrink_CvA_LFC1 = lfcShrink(dds.gene, contrast = c("group", "C", "A"), res = res_CvA_LFC1, type = "ashr")
summary(res_shrink_CvA_LFC1)

# Filter for significant genes (adjusted p-value < 0.05) for NULL hypothesis of LFC = 0
sig_BvA_0 =subset(res_shrink_BvA,res_shrink_BvA$padj<0.05)
sig_CvA_0 = subset(res_shrink_CvA,res_shrink_CvA$padj<0.05)

# Filter for significant genes (adjusted p-value < 0.05) for NULL hypothesis of LFC < 1
sig_BvA_LFC1 = subset(res_shrink_BvA_LFC1,res_shrink_BvA_LFC1$padj < 0.05)
sig_CvA_LFC1 =  subset(res_shrink_CvA_LFC1,res_shrink_CvA_LFC1$padj < 0.05)

# Sort by decreasing LFC (NULL hypothesis of LFC < 1)
sig_BvA_LFC1_sorted = sig_BvA_LFC1[order(sig_BvA_LFC1$log2FoldChange, decreasing = TRUE), ]
sig_CvA_LFC1_sorted = sig_CvA_LFC1[order(sig_CvA_LFC1$log2FoldChange, decreasing = TRUE), ]

# Write results for significant genes sorted for  LFC < 1 to CSV 
write.csv(sig_BvA_LFC1_sorted, file = "Significant.Genes.BvsA.csv")
write.csv(sig_CvA_LFC1_sorted, file = "Significant.Genes.CvsA.csv")

```

```{r sig genes shrunk, include = FALSE}
# Check the number of significant genes after filtering
dim(sig_BvA_0)[1]  # Significant genes for B vs A
dim(sig_CvA_0)[1]  # Significant genes for C vs A
dim(sig_BvA_LFC1)[1]  # Significant genes for B vs A with LFC < 1
dim(sig_CvA_LFC1)[1]  # Significant genes for C vs A with LFC < 1
```


<div style="text-align: justify ; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

In differential expression analysis, the null hypothesis of LFC = 0 assumes no change in gene expression between conditions, identifying genes with any statistically significant fold change. In contrast, the null hypothesis LFC < 1 applies a stricter threshold, considering only genes with a fold change greater than 2 (since LFC = log2(FC)), thus reducing the number of significant genes.

</div>

<div style="text-align: center; font-size: 18px; font-family: 'Times New Roman', Times, serif;">
 **Table 2 :Number of significant genes for B vs. A and C vs. A contrasts under different LFC hypotheses.** 

| Contrast | LFC Hypothesis | Unshrunk LFC | shrunk LFC |
|----------|----------------|--------------|------------|
| B vs A   | LFC = 0        |   511        |    511     |
| B vs A   | LFC < 1        |   48         |    48      |
| C vs A   | LFC = 0        |   38         |    38      |
| C vs A   | LFC < 1        |   4          |    4       |

</div>



```{r MA plot for unshrunk LFC,echo=FALSE, message=FALSE, fig.cap="**(a)**",fig.align='center', fig.width=8}

# Split the window into 4
par(mfrow = c(1,4))

# MA plot for standard NULL hypothesis (LFC = 0) for B vs A contrast
DESeq2::plotMA(res.g.BvA,alpha = 0.05, main="MA B vs A (LFC = 0)", ylim = c(-30,30))


# MA plot for NULL hypothesis of LFC < 1 for B vs A contrast
DESeq2::plotMA(res_BvA_LFC1,alpha = 0.05, main="MA B vs A (LFC < 1)",ylim = c(-30,30))


# MA plot for standard NULL hypothesis (LFC = 0) for C vs A contrast
DESeq2::plotMA(res.g.CvA,alpha = 0.05, main="MA C vs A (LFC = 0)",ylim = c(-30,30))


#  MA plot for NULL hypothesis of LFC < 1 for C vs A contrast
DESeq2::plotMA(res_CvA_LFC1, alpha = 0.05,main="MA C vs A (LFC < 1)",ylim = c(-30,30))

```



```{r MA plot shrunken LFC , warning=FALSE,echo=FALSE, message=FALSE,fig.cap="**(b)**",fig.align='center',fig.width=8}

par(mfrow = c(1,4))

# MA plot for shrunken  NULL hypothesis of LFC < 0 for Bvs A contrast
DESeq2::plotMA(res_shrink_BvA, alpha = 0.05, main="MA B vs A (LFC = 0 )",ylim = c(-30,30))

# MA plot for NULL hypothesis of LFC < 1 for Bvs A contrast
DESeq2::plotMA(res_shrink_BvA_LFC1, alpha = 0.05, main="MA B vs A (LFC < 1)",ylim = c(-30,30))

# MA plot for shrunken NULL hypothesis of LFC = 0for Bvs A contrast
DESeq2::plotMA(res_shrink_CvA, alpha = 0.05, main="MA C vs A (LFC = 0 )",ylim = c(-30,30))


# MA plot for shrunken  NULL hypothesis of LFC < 1 for C vs A contrast
DESeq2::plotMA(res_shrink_CvA_LFC1, alpha = 0.05,  main="MA C vs A (LFC < 1)",ylim = c(-30,30))

```


<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

**Figure 5: MA plots for different contrasts (B vs. A and C vs. A) under different null hypotheses ( standard NULL hypothesis (LFC = 0)  and LFC < 1) for unshrunken and shrunken LFC, with significant genes highlighted in blue.
(a) MA plots for unshrunken LFC, showing fewer significant genes under LFC < 1 compared to LFC = 0, with points more widely spread along the trend line.
(b) MA plots for shrunken LFC, showing fewer significant genes under LFC 1 but reduce noise along the trend line due to the stabilization effect of LFC shrinkage and adjusted extreme fold changes.**

</div>


<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

As shown in **Table 2**, the number of significant genes is lower under LFC < 1 for both shrunken and unshrunken LFC, as many genes with smaller fold changes are excluded. After LFC shrinkage, the number of significant genes remains the same for both null hypotheses, suggesting that shrinkage stabilizes LFC estimates while maintaining statistical significance. The associated MA plots **(Figure 5)** illustrate this effect, where fewer genes are highlighted in blue under LFC < 1.

LFC shrinkage is applied to stabilize the fold change estimates, especially for genes with extreme values that could be driven by noise or small sample sizes. Shrunken LFC MA plots **(Figure 5b)** show reduced noise and a more stable distribution along the fitted line compared to unshrunk LFC MA plots **(Figure 5a)**, highlighting the stabilizing effect of LFC shrinkage. The LFC shrinkage method pulls extreme values closer to zero, making fold changes more reliable.LFC shrinkage ensures more robust and biologically meaningful results by reducing the impact of outliers.

</div>

```{r MA for standard null hypothesis ( LFC 0) shrunk and unshrunk , include = TRUE, echo=FALSE ,message=FALSE,eval=interactive()}

par(mfrow = c(1,2))

# MA plot for standard NULL hypothesis unshrunk for contrast B Vs A  
DESeq2::plotMA(res.g.BvA, main="MA B vs A (LFC = 0)",ylim = c(-30,30))


# MA plot for standard NULL hypothesis shrunk for contrast B vs A 
DESeq2::plotMA(res_shrink_BvA, main="MA B vs A (LFC = 0)",ylim = c(-30,30))

# MA plot for strandard NULL hypothesis unshrunk For C vs A contrast 
DESeq2::plotMA(res.g.CvA, main="MA C vs A (LFC = 0)",ylim = c(-30,30))


# MA plot for strandard NULL hypothesis hrunk For C vs A contrast 
DESeq2::plotMA(res_shrink_CvA, main="MA C vs A (LFC = 0)",ylim = c(-30,30))

```

```{r DEG with one factor design,include=FALSE}
# creating dds with only group
dds.group = DESeqDataSetFromMatrix(countData = counttable_gene,colData = coltable ,design = ~  group)

dds.group = dds.group[rowSums(counts(dds.group) >= 10) >= 3, ] 
dds.group =  DESeq(dds.group)
rld.g = rlog(dds.group, blind=TRUE)

res.group.BvA  = results(dds.group ,contrast=c("group","B","A"))
res.group.CvA  = results(dds.group ,contrast=c("group","C","A"))
summary(res.group.BvA,alpha=0.05)
summary(res.group.CvA,alpha=0.05)

```

```{r batch correction using limma , echo =FALSE ,message=FALSE}
library(limma)
  mydesign = model.matrix(design(dds.group),colData(dds.group))
  b.corrected = limma::removeBatchEffect(assay(rld.g), batch=colData(dds.gene)$batch, design=mydesign)
  write.csv(b.corrected,file="BatchCorrected.Rlog.csv",quote=FALSE)
```

```{r PCA batch uncorrected vs corrected, fig.width=10,fig.height=7,echo = FALSE,message=FALSE}
library(gridExtra)
library(grid)

# Create the PCA plots for both original and batch-corrected data
p1 <- plotPCAWithSampleNames(assay(rld_gene), targets = coltable, intgroup = c("group"))

p2 <- plotPCAWithSampleNames(b.corrected, targets = coltable, intgroup = c("group"))


grid.arrange(p1, p2, ncol = 2)
grid.text("(a)", x = 0.25, y = 0.02, gp = gpar(fontsize = 12, fontface = "bold"))
grid.text("(b)", x = 0.75, y = 0.02, gp = gpar(fontsize = 12, fontface = "bold"))
```

<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

**Figure 6 : PCA ( Principal Component Analysis) plots demonstrating batch effect removal on gene level data coloured by groups ( A,B and C). (a) PCA plot without batch effect removal on rlog transformed gene level data showing PC1 68.9 % and PC2 7.3%. (b) PCA plot with with batch effect removal using limma on rlog transformed gene level data showing PC1 76.9% and PC2 7%**

</div>

<div style="text-align: justify; font-size: 17px; font-family: 'Times New Roman', Times, serif;">

After batch correction using limma, the PCA plots **(Figure 6)** show an increase in variation explained by PC1 (76.9% in **Figure 6b** compared to 68.9% in **Figure 6a**). This suggests that batch correction has successfully emphasized the biological differences between the groups. The persistent clustering of samples in groups A and C, evident in both PCA before and after correction, may indicate a greater similarity in gene expression between these groups. The samples s4.c2, s10.c2, and s8.c2 exhibit distinct separation from other samples after batch correction, highlighting their unique expression profiles.

</div>






